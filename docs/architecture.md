# Архитектура платформы LowCodeRetail

Платформа LowCodeRetail спроектирована как набор взаимодействующих микросервисов, построенных на едином фреймворке. Цель такой архитектуры — обеспечить модульность, масштабируемость, независимую разработку и развертывание отдельных компонентов системы.

## Общая концепция

В основе архитектуры лежит разделение бизнес-логики на логически независимые сервисы (например, Core, WMS, Purchase, Orders и т.д.). Каждый сервис отвечает за свою доменную область и управляет собственными данными. Взаимодействие между сервисами осуществляется преимущественно через HTTP API.

Ключевым элементом, обеспечивающим единство и ускорение разработки, является **`core_sdk`** (Core Software Development Kit) — общая библиотека, предоставляющая стандартные инструменты и абстракции.

## Компоненты архитектуры

### 1. Микросервисы

Каждый микросервис представляет собой независимое FastAPI приложение, контейнеризованное с помощью Docker.

*   **Core Service (`core`):**
    *   **Назначение:** Центральный сервис, отвечающий за базовые сущности платформы и сквозные функции.
    *   **Основные сущности:** Пользователи (`User`), Компании (`Company`), Группы пользователей (`Group`), Права доступа (`Permission`).
    *   **Функциональность:**
        *   Управление пользователями (CRUD, аутентификация, авторизация).
        *   Управление компаниями и группами.
        *   Централизованное управление правами доступа.
        *   Предоставление API для других сервисов для получения информации о пользователях, компаниях и проверки прав.
    *   **Технологии:** FastAPI, SQLModel, PostgreSQL, Alembic (для миграций), Taskiq (для фоновых задач, например, рассылки уведомлений).
    *   Является "поставщиком" данных о пользователях для других сервисов.

*   **Специализированные микросервисы (например, `WMS`, `Purchase`, `OMS`, `Catalog`):**
    *   **Назначение:** Реализуют специфическую бизнес-логику своей доменной области (управление складом, закупками, заказами, каталогом товаров и т.д.).
    *   **Данные:** Обычно имеют собственную базу данных (или схему в общей БД) для хранения своих сущностей.
    *   **Взаимодействие:**
        *   Могут предоставлять API для других сервисов.
        *   Могут потреблять API других сервисов (например, `core` для получения информации о пользователе, создавшем заказ).
        *   Используют `core_sdk` для унификации разработки.
    *   **Пример (WMS - Warehouse Management Service):**
        *   Сущности: Товары на складе (`StockLevel`), Складские операции, Местоположения на складе.
        *   API: Получение остатков, резервирование товаров, проведение инвентаризаций.

### 2. `core_sdk` (Core Software Development Kit)

Общая Python библиотека, устанавливаемая как зависимость в каждый микросервис (или доступная через общую кодовую базу/симлинки при локальной разработке).

*   **Назначение:**
    *   Предоставление стандартных инструментов для разработки микросервисов.
    *   Уменьшение дублирования кода.
    *   Обеспечение консистентности между сервисами.
*   **Ключевые модули `core_sdk`:**
    *   **`app_setup`**: Фабрика для создания FastAPI приложений (`create_app_with_sdk_setup`) с предустановленными middleware (CORS, сессии БД, аутентификация) и управлением жизненным циклом (инициализация БД, HTTP-клиента, брокера).
    *   **`config`**: Базовый класс `BaseAppSettings` для типизированной конфигурации сервисов через Pydantic (загрузка из `.env` и переменных окружения).
    *   **`db`**:
        *   `BaseModelWithMeta`: Базовая SQLModel модель с общими полями (`id`, `lsn`, `created_at`, `updated_at`, `vars`, `company_id`).
        *   Утилиты для управления сессиями SQLAlchemy (`init_db`, `close_db`, `managed_session`, `get_current_session`, `get_session_dependency`).
    *   **`data_access`**:
        *   `ModelRegistry`: Центральный реестр для регистрации локальных и удаленных моделей. Позволяет сервисам "знать" о моделях друг друга и способах доступа к ним.
        *   `BaseDataAccessManager`: Слой доступа к данным для локальных моделей (CRUD, фильтрация, пагинация).
        *   `RemoteDataAccessManager`: Слой доступа к данным для удаленных моделей, использующий `RemoteServiceClient`.
        *   `DataAccessManagerFactory`: Фабрика для получения нужного DAM (локального или удаленного) на основе `ModelRegistry`.
        *   `BrokerTaskProxy`: Позволяет выполнять методы DAM асинхронно через брокер задач.
    *   **`clients`**:
        *   `RemoteServiceClient`: Базовый HTTP-клиент (`httpx`) для взаимодействия с API других сервисов.
        *   `global_http_client_lifespan`: Управление глобальным экземпляром `httpx.AsyncClient`.
    *   **`crud.factory`**:
        *   `CRUDRouterFactory`: Автоматическая генерация FastAPI роутеров для стандартных CRUD операций на основе моделей и схем, зарегистрированных в `ModelRegistry`.
    *   **`middleware`**:
        *   `AuthMiddleware`: Проверка JWT токенов и установка `request.user`.
        *   `DBSessionMiddleware`: Управление сессией БД для каждого HTTP-запроса.
    *   **`dependencies.auth`**: FastAPI зависимости для получения текущего пользователя и проверки прав (`get_current_user`, `require_permission`).
    *   **`security`**: Функции для работы с JWT (создание, верификация) и хеширования паролей.
    *   **`schemas`**: Общие Pydantic/SQLModel схемы (например, `AuthenticatedUser`, `Token`, `PaginatedResponse`, `UserRead` для межсервисного обмена).
    *   **`broker`**: Настройка и задачи для Taskiq (включая `execute_dam_operation` для выполнения методов DAM в воркерах).
    *   `worker_setup`: Утилиты для инициализации контекста воркеров Taskiq.
    *   `exceptions`: Общие классы исключений.
    *   `logging_config`: Базовая настройка логирования.

### 3. База данных (PostgreSQL)

*   **Основная БД (`main_db`):** Используется `core` сервисом для хранения пользователей, компаний, групп и прав.
*   **БД специализированных сервисов (например, `wms_db`, `purchase_db`):** Каждый сервис может иметь свою собственную базу данных или использовать отдельные схемы в общей физической БД. Это обеспечивает изоляцию данных.
    *   Модели этих сервисов наследуются от `core_sdk.db.BaseModelWithMeta`.
*   **Миграции:** Alembic используется для управления миграциями схемы БД для каждого сервиса, имеющего собственную БД/схемы.

### 4. Кэш и Брокер сообщений (Redis)

*   **Redis** используется для двух основных целей:
    *   **Бэкенд результатов для Taskiq:** Хранение результатов выполнения фоновых задач.
    *   **Брокер сообщений для Taskiq (Redis Streams):** Передача задач от API-сервисов к воркерам.
    *   **Кэширование (опционально):** Может использоваться для кэширования часто запрашиваемых данных.

### 5. Контейнеризация (Docker)

*   Каждый микросервис (API и его воркеры) упаковывается в Docker-контейнер.
*   `docker-compose.yml` используется для оркестрации всех сервисов, базы данных и Redis в локальном окружении разработки.
*   Предоставляются `Dockerfile` для сборки образов сервисов.

### 6. Взаимодействие компонентов (Потоки данных)

#### A. HTTP Запрос к CRUD эндпоинту, созданному `CRUDRouterFactory`:

1.  Клиент отправляет HTTP запрос (например, `GET /api/v1/products?name__like=Test`).
2.  Запрос попадает в FastAPI приложение сервиса (например, WMS).
3.  **Middleware `core_sdk`:**
    *   `CORSMiddleware` обрабатывает CORS-заголовки.
    *   `DBSessionMiddleware` открывает сессию БД (`managed_session`).
    *   `AuthMiddleware` проверяет JWT токен, если эндпоинт защищен, и устанавливает `request.user`.
4.  FastAPI направляет запрос в соответствующий эндпоинт, сгенерированный `CRUDRouterFactory`.
5.  **Зависимости FastAPI:**
    *   `get_current_user` или `require_permission` (если эндпоинт защищен) проверяют авторизацию.
    *   `get_dam_factory` создает экземпляр `DataAccessManagerFactory`.
    *   Фильтр (например, `ProductFilter`) инстанцируется и заполняется из query-параметров.
6.  Эндпоинт вызывает метод `get_manager("Product")` у `DataAccessManagerFactory`.
7.  **`DataAccessManagerFactory`:**
    *   Обращается к `ModelRegistry` для получения информации о модели "Product".
    *   Если "Product" — локальная модель, создается экземпляр `ProductManager` (или `BaseDataAccessManager`).
8.  **`ProductManager` (метод `list`):**
    *   Получает текущую сессию БД через `get_current_session()`.
    *   Применяет фильтры и пагинацию, выполняет SQL-запрос к своей БД.
    *   Возвращает результат (список объектов и информацию для пагинации).
9.  Результат сериализуется в соответствии с `response_model` (например, `PaginatedResponse[ProductRead]`) и отправляется клиенту.
10. `DBSessionMiddleware` закрывает сессию БД.

#### B. HTTP Запрос к эндпоинту, использующему удаленную модель:

1.  Клиент отправляет запрос к сервису A, который должен получить данные из сервиса B (например, сервис Orders запрашивает информацию о пользователе из Core).
2.  Шаги 1-5 аналогичны предыдущему сценарию.
3.  Эндпоинт сервиса A вызывает `dam_factory.get_manager("CoreUser")`.
4.  **`DataAccessManagerFactory`:**
    *   Обращается к `ModelRegistry` для получения информации о "CoreUser".
    *   Обнаруживает, что это удаленная модель с `RemoteConfig`.
    *   Создает экземпляр `RemoteDataAccessManager`.
5.  **`RemoteDataAccessManager` (метод `get`):**
    *   Использует свой экземпляр `RemoteServiceClient` (который получил глобальный `httpx.AsyncClient` и, возможно, токен текущего пользователя из `get_optional_token`).
    *   Формирует HTTP запрос к сервису B (Core) по URL, указанному в `RemoteConfig` (например, `http://core-service/api/v1/users/{user_id}`).
    *   Отправляет запрос и получает ответ от Core сервиса.
    *   Десериализует ответ в схему `CoreUserRead`.
6.  Результат возвращается в эндпоинт сервиса A и далее клиенту.

#### C. Выполнение операции DAM через брокер задач (Taskiq):

1.  API эндпоинт сервиса решает выполнить длительную операцию (например, активация компании).
2.  Получает DAM для нужной модели (например, `CompanyManager`).
3.  Вызывает метод через прокси брокера: `await company_manager.broker.activate_company(company_id, _broker_timeout=T)`.
4.  **`BrokerTaskProxy` (`core_sdk.data_access.broker_proxy`):**
    *   Сериализует аргументы.
    *   Отправляет задачу `execute_dam_operation` в Taskiq с именем модели ("Company"), именем метода ("activate_company") и аргументами.
    *   Возвращает объект `TaskiqResult`.
5.  API эндпоинт может:
    *   Немедленно вернуть `202 Accepted`.
    *   Ожидать результат: `await task_result.wait_result(timeout=T)`.
6.  **Воркер Taskiq (например, `core-worker`):**
    *   При старте воркера выполняется `initialize_worker_context` (из `core_sdk.worker_setup`), который инициализирует БД и `ModelRegistry` для `core` сервиса (на основе `core/app/registry_config.py`).
    *   Воркер получает задачу `execute_dam_operation` из Redis.
    *   **Задача `execute_dam_operation` (`core_sdk.broker.tasks`):**
        *   Открывает сессию БД через `managed_session`.
        *   Создает `DataAccessManagerFactory` (используя `ModelRegistry`, сконфигурированный для воркера).
        *   Получает `CompanyManager`.
        *   Десериализует аргументы.
        *   Вызывает `company_manager.activate_company(company_id)`.
        *   `CompanyManager.activate_company()` выполняет логику, изменяет данные в БД, коммитит сессию.
        *   Результат выполнения сериализуется и возвращается через Taskiq.
7.  Если API эндпоинт ожидал результат, он его получает и обрабатывает.

## Схема взаимодействия (упрощенная)

```mermaid
graph TD
    Client[Клиент] -->|HTTP API| Gateway[API Gateway / Load Balancer (опционально)]

    Gateway --> ServiceA[Микросервис A (FastAPI)]
    Gateway --> ServiceB[Микросервис B (FastAPI)]
    Gateway --> CoreService[Core Service (FastAPI)]

    subgraph "Инфраструктура"
        PostgreSQL[PostgreSQL]
        Redis[Redis]
    end

    ServiceA -->|SQL| PostgreSQL
    ServiceA -->|HTTP API через RemoteDAM| ServiceB
    ServiceA -->|HTTP API через RemoteDAM| CoreService
    ServiceA -->|Задачи| TaskiqBroker[Taskiq Брокер (Redis Streams)]

    ServiceB -->|SQL| PostgreSQL
    ServiceB -->|HTTP API через RemoteDAM| CoreService

    CoreService -->|SQL| PostgreSQL

    TaskiqBroker --> WorkerA[Воркер Сервиса A (Taskiq)]
    TaskiqBroker --> WorkerCore[Воркер Core Сервиса (Taskiq)]

    WorkerA -->|SQL через DAM| PostgreSQL
    WorkerCore -->|SQL через DAM| PostgreSQL

    classDef service fill:#daf,stroke:#333,stroke-width:2px;
    classDef db fill:#f9f,stroke:#333,stroke-width:2px;
    classDef broker fill:#9cf,stroke:#333,stroke-width:2px;
    classDef client fill:#fff,stroke:#333,stroke-width:2px;

    class Client,Gateway client;
    class ServiceA,ServiceB,CoreService service;
    class PostgreSQL db;
    class Redis,TaskiqBroker broker;
    class WorkerA,WorkerCore service;
```

## Преимущества архитектуры

*   **Модульность и слабая связанность:** Сервисы разрабатываются и развертываются независимо.
*   **Технологическая гибкость:** Хотя фреймворк предлагает FastAPI/SQLModel, отдельные сервисы теоретически могут использовать другие технологии для специфических задач (но это усложнит использование `core_sdk`).
*   **Масштабируемость:** Отдельные сервисы можно масштабировать независимо друг от друга.
*   **Отказоустойчивость:** Сбой одного сервиса не обязательно приводит к отказу всей системы (если зависимости обработаны корректно).
*   **Ускорение разработки:** `core_sdk` и `CRUDRouterFactory` значительно сокращают количество шаблонного кода.
*   **Единообразие:** Общие подходы к конфигурации, логированию, доступу к данным.

## Потенциальные сложности

*   **Сетевые задержки:** Взаимодействие между сервисами по HTTP вносит дополнительные задержки.
*   **Распределенные транзакции:** Управление транзакциями, охватывающими несколько сервисов, является сложной задачей (обычно избегается в пользу eventual consistency или саг).
*   **Сложность отладки и мониторинга:** Требуются инструменты для трассировки запросов между сервисами и централизованного сбора логов.
*   **Управление контрактами API:** Изменения в API одного сервиса могут повлиять на другие. Необходимо версионирование API и четкие контракты (OpenAPI).
*   **Развертывание и оркестрация:** Требуется система оркестрации контейнеров (например, Kubernetes) для управления множеством сервисов в production. Docker Compose хорошо подходит для разработки и тестирования.
```

---

**Рекомендации по дополнению:**

*   **Детализируйте потоки данных:** Для наиболее важных бизнес-процессов можно нарисовать более подробные sequence diagrams, показывающие вызовы между компонентами.
*   **Стратегии обработки ошибок:** Как обрабатываются ошибки связи между сервисами? Используются ли паттерны типа Circuit Breaker?
*   **Eventual Consistency:** Если используются асинхронные операции и нет распределенных транзакций, упомяните, как достигается согласованность данных (например, через события или компенсационные транзакции).
*   **Безопасность:** Помимо аутентификации/авторизации, упомяните другие аспекты безопасности, если они важны (защита от OWASP Top 10, шифрование и т.д.).
*   **Развертывание в Production:** Кратко опишите, как предполагается развертывать систему в production (например, Kubernetes, Helm, CI/CD).

Этот документ должен дать хорошее представление об архитектуре вашей системы. Вы можете его расширять и детализировать по мере развития проекта.